*** bdkwithoutdocs.kt	2022-04-07 14:31:55.000000000 -0400
--- bdk.kt	2022-04-08 16:52:34.000000000 -0400
***************
*** 17,131 ****
  // compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
  // helpers directly inline like we're doing here.
  
  import com.sun.jna.Library
  import com.sun.jna.Native
  import com.sun.jna.Pointer
  import com.sun.jna.Structure
  import com.sun.jna.ptr.ByReference
  import java.nio.ByteBuffer
  import java.nio.ByteOrder
  import java.util.concurrent.atomic.AtomicBoolean
  import java.util.concurrent.atomic.AtomicLong
  import java.util.concurrent.locks.ReentrantLock
  import kotlin.concurrent.withLock
  
  // The Rust Buffer and 3 templated methods (alloc, free, reserve).
  // This is a helper for safely working with byte buffers returned from the Rust code.
  // A rust-owned buffer is represented by its capacity, its current length, and a
  // pointer to the underlying data.
  
  @Structure.FieldOrder("capacity", "len", "data")
  open class RustBuffer : Structure() {
      @JvmField var capacity: Int = 0
      @JvmField var len: Int = 0
      @JvmField var data: Pointer? = null
  
      class ByValue : RustBuffer(), Structure.ByValue
      class ByReference : RustBuffer(), Structure.ByReference
  
      companion object {
          internal fun alloc(size: Int = 0) = rustCall() { status ->
              _UniFFILib.INSTANCE.ffi_bdk_9c03_rustbuffer_alloc(size, status).also {
                  if(it.data == null) {
                     throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
                 }
              }
          }
  
          internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
              _UniFFILib.INSTANCE.ffi_bdk_9c03_rustbuffer_free(buf, status)
          }
  
          internal fun reserve(buf: RustBuffer.ByValue, additional: Int) = rustCall() { status ->
              _UniFFILib.INSTANCE.ffi_bdk_9c03_rustbuffer_reserve(buf, additional, status)
          }
      }
  
      @Suppress("TooGenericExceptionThrown")
      fun asByteBuffer() =
          this.data?.getByteBuffer(0, this.len.toLong())?.also {
              it.order(ByteOrder.BIG_ENDIAN)
          }
  }
  
  /**
!  * The equivalent of the `*mut RustBuffer` type.
!  * Required for callbacks taking in an out pointer.
!  *
!  * Size is the sum of all values in the struct.
   */
  class RustBufferByReference : ByReference(16) {
      /**
       * Set the pointed-to `RustBuffer` to the given value.
       */
      fun setValue(value: RustBuffer.ByValue) {
          // NOTE: The offsets are as they are in the C-like struct.
          val pointer = getPointer()
          pointer.setInt(0, value.capacity)
          pointer.setInt(4, value.len)
          pointer.setPointer(8, value.data)
      }
  }
  
  // This is a helper for safely passing byte references into the rust code.
  // It's not actually used at the moment, because there aren't many things that you
  // can take a direct pointer to in the JVM, and if we're going to copy something
  // then we might as well copy it into a `RustBuffer`. But it's here for API
  // completeness.
  
  @Structure.FieldOrder("len", "data")
  open class ForeignBytes : Structure() {
      @JvmField var len: Int = 0
      @JvmField var data: Pointer? = null
  
      class ByValue : ForeignBytes(), Structure.ByValue
  }
  
  
  // A helper for structured writing of data into a `RustBuffer`.
  // This is very similar to `java.nio.ByteBuffer` but it knows how to grow
  // the underlying `RustBuffer` on demand.
  //
  // TODO: we should benchmark writing things into a `RustBuffer` versus building
  // up a bytearray and then copying it across.
! 
  class RustBufferBuilder() {
      var rbuf = RustBuffer.ByValue()
      var bbuf: ByteBuffer? = null
  
      init {
          val rbuf = RustBuffer.alloc(16) // Totally arbitrary initial size
          rbuf.writeField("len", 0)
          this.setRustBuffer(rbuf)
      }
  
      internal fun setRustBuffer(rbuf: RustBuffer.ByValue) {
          this.rbuf = rbuf
          this.bbuf = this.rbuf.data?.getByteBuffer(0, this.rbuf.capacity.toLong())?.also {
              it.order(ByteOrder.BIG_ENDIAN)
              it.position(rbuf.len)
          }
      }
  
      fun finalize() : RustBuffer.ByValue {
          val rbuf = this.rbuf
--- 17,145 ----
  // compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
  // helpers directly inline like we're doing here.
  
  import com.sun.jna.Library
  import com.sun.jna.Native
  import com.sun.jna.Pointer
  import com.sun.jna.Structure
  import com.sun.jna.ptr.ByReference
  import java.nio.ByteBuffer
  import java.nio.ByteOrder
  import java.util.concurrent.atomic.AtomicBoolean
  import java.util.concurrent.atomic.AtomicLong
  import java.util.concurrent.locks.ReentrantLock
  import kotlin.concurrent.withLock
  
  // The Rust Buffer and 3 templated methods (alloc, free, reserve).
  // This is a helper for safely working with byte buffers returned from the Rust code.
  // A rust-owned buffer is represented by its capacity, its current length, and a
  // pointer to the underlying data.
  
+ /**
+  * @suppress
+  */
  @Structure.FieldOrder("capacity", "len", "data")
  open class RustBuffer : Structure() {
      @JvmField var capacity: Int = 0
      @JvmField var len: Int = 0
      @JvmField var data: Pointer? = null
  
      class ByValue : RustBuffer(), Structure.ByValue
      class ByReference : RustBuffer(), Structure.ByReference
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun alloc(size: Int = 0) = rustCall() { status ->
              _UniFFILib.INSTANCE.ffi_bdk_9c03_rustbuffer_alloc(size, status).also {
                  if(it.data == null) {
                     throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
                 }
              }
          }
  
          internal fun free(buf: RustBuffer.ByValue) = rustCall() { status ->
              _UniFFILib.INSTANCE.ffi_bdk_9c03_rustbuffer_free(buf, status)
          }
  
          internal fun reserve(buf: RustBuffer.ByValue, additional: Int) = rustCall() { status ->
              _UniFFILib.INSTANCE.ffi_bdk_9c03_rustbuffer_reserve(buf, additional, status)
          }
      }
  
      @Suppress("TooGenericExceptionThrown")
      fun asByteBuffer() =
          this.data?.getByteBuffer(0, this.len.toLong())?.also {
              it.order(ByteOrder.BIG_ENDIAN)
          }
  }
  
+ ///**
+ // * The equivalent of the `*mut RustBuffer` type.
+ // * Required for callbacks taking in an out pointer.
+ // *
+ // * Size is the sum of all values in the struct.
+ // */
  /**
!  * @suppress
   */
  class RustBufferByReference : ByReference(16) {
      /**
       * Set the pointed-to `RustBuffer` to the given value.
       */
      fun setValue(value: RustBuffer.ByValue) {
          // NOTE: The offsets are as they are in the C-like struct.
          val pointer = getPointer()
          pointer.setInt(0, value.capacity)
          pointer.setInt(4, value.len)
          pointer.setPointer(8, value.data)
      }
  }
  
  // This is a helper for safely passing byte references into the rust code.
  // It's not actually used at the moment, because there aren't many things that you
  // can take a direct pointer to in the JVM, and if we're going to copy something
  // then we might as well copy it into a `RustBuffer`. But it's here for API
  // completeness.
  
+ /**
+  * @suppress
+  */
  @Structure.FieldOrder("len", "data")
  open class ForeignBytes : Structure() {
      @JvmField var len: Int = 0
      @JvmField var data: Pointer? = null
  
      class ByValue : ForeignBytes(), Structure.ByValue
  }
  
  
  // A helper for structured writing of data into a `RustBuffer`.
  // This is very similar to `java.nio.ByteBuffer` but it knows how to grow
  // the underlying `RustBuffer` on demand.
  //
  // TODO: we should benchmark writing things into a `RustBuffer` versus building
  // up a bytearray and then copying it across.
! /**
!  * @suppress
!  */
  class RustBufferBuilder() {
      var rbuf = RustBuffer.ByValue()
      var bbuf: ByteBuffer? = null
  
      init {
          val rbuf = RustBuffer.alloc(16) // Totally arbitrary initial size
          rbuf.writeField("len", 0)
          this.setRustBuffer(rbuf)
      }
  
      internal fun setRustBuffer(rbuf: RustBuffer.ByValue) {
          this.rbuf = rbuf
          this.bbuf = this.rbuf.data?.getByteBuffer(0, this.rbuf.capacity.toLong())?.also {
              it.order(ByteOrder.BIG_ENDIAN)
              it.position(rbuf.len)
          }
      }
  
      fun finalize() : RustBuffer.ByValue {
          val rbuf = this.rbuf
***************
*** 232,304 ****
--- 246,327 ----
  // This would be a good candidate for isolating in its own ffi-support lib.
  // Error runtime.
  @Structure.FieldOrder("code", "error_buf")
  internal open class RustCallStatus : Structure() {
      @JvmField var code: Int = 0
      @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()
  
      fun isSuccess(): Boolean {
          return code == 0
      }
  
      fun isError(): Boolean {
          return code == 1
      }
  
      fun isPanic(): Boolean {
          return code == 2
      }
  }
  
+ /**
+  * @suppress
+  */
  class InternalException(message: String) : Exception(message)
  
+ /**
+  * @suppress
+  */
  // Each top-level error class has a companion object that can lift the error from the call status's rust buffer
  interface CallStatusErrorHandler<E> {
      fun lift(error_buf: RustBuffer.ByValue): E;
  }
  
  // Helpers for calling Rust
  // In practice we usually need to be synchronized to call this safely, so it doesn't
  // synchronize itself
  
  // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
  private inline fun <U, E: Exception> rustCallWithError(errorHandler: CallStatusErrorHandler<E>, callback: (RustCallStatus) -> U): U {
      var status = RustCallStatus();
      val return_value = callback(status)
      if (status.isSuccess()) {
          return return_value
      } else if (status.isError()) {
          throw errorHandler.lift(status.error_buf)
      } else if (status.isPanic()) {
          // when the rust code sees a panic, it tries to construct a rustbuffer
          // with the message.  but if that code panics, then it just sends back
          // an empty buffer.
          if (status.error_buf.len > 0) {
              throw InternalException(String.lift(status.error_buf))
          } else {
              throw InternalException("Rust panic")
          }
      } else {
          throw InternalException("Unknown rust call status: $status.code")
      }
  }
  
+ /**
+  * @suppress
+  */
  // CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
  object NullCallStatusErrorHandler: CallStatusErrorHandler<InternalException> {
      override fun lift(error_buf: RustBuffer.ByValue): InternalException {
          RustBuffer.free(error_buf)
          return InternalException("Unexpected CALL_ERROR")
      }
  }
  
  // Call a rust function that returns a plain value
  private inline fun <U> rustCall(callback: (RustCallStatus) -> U): U {
      return rustCallWithError(NullCallStatusErrorHandler, callback);
  }
  
  // Contains loading, initialization code,
  // and the FFI Function declarations in a com.sun.jna.Library.
  @Synchronized
  private fun findLibraryName(componentName: String): String {
      val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
      if (libOverride != null) {
          return libOverride
***************
*** 430,479 ****
--- 453,508 ----
      uniffi_out_err: RustCallStatus
      ): Unit
  
      fun ffi_bdk_9c03_rustbuffer_reserve(buf: RustBuffer.ByValue,additional: Int,
      uniffi_out_err: RustCallStatus
      ): RustBuffer.ByValue
  
      
  }
  
  // Public interface members begin here.
  
  // Interface implemented by anything that can contain an object reference.
  //
  // Such types expose a `destroy()` method that must be called to cleanly
  // dispose of the contained objects. Failure to call this method may result
  // in memory leaks.
  //
  // The easiest way to ensure this method is called is to use the `.use`
  // helper method to execute a block and destroy the object at the end.
+ /**
+  * @suppress
+  */
  interface Disposable {
      fun destroy()
      companion object {
          fun destroy(vararg args: Any?) {
              args.filterIsInstance<Disposable>()
                  .forEach(Disposable::destroy)
          }
      }
  }
  
+ /**
+  * @suppress
+  */
  inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
      try {
          block(this)
      } finally {
          try {
              // N.B. our implementation is on the nullable type `Disposable?`.
              this?.destroy()
          } catch (e: Throwable) {
              // swallow
          }
      }
  
  // The base class for all UniFFI Object types.
  //
  // This class provides core operations for working with the Rust `Arc<T>` pointer to
  // the live Rust struct on the other side of the FFI.
  //
  // There's some subtlety here, because we have to be careful not to operate on a Rust
  // struct after it has been dropped, and because we must expose a public API for freeing
  // the Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
***************
*** 533,572 ****
--- 562,604 ----
  //      Otherwise we atomically decrement and check the counter.
  //      If it has reached zero then we destroy the underlying Rust struct.
  //
  // Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
  // and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
  //
  // The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
  // called *and* all in-flight method calls have completed, avoiding violating any of the expectations
  // of the underlying Rust code.
  //
  // In the future we may be able to replace some of this with automatic finalization logic, such as using
  // the new "Cleaner" functionaility in Java 9. The above scheme has been designed to work even if `destroy` is
  // invoked by garbage-collection machinery rather than by calling code (which by the way, it's apparently also
  // possible for the JVM to finalize an object while there is an in-flight call to one of its methods [1],
  // so there would still be some complexity here).
  //
  // Sigh...all of this for want of a robust finalization mechanism.
  //
  // [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
  //
+ /**
+  * @suppress
+  */
  abstract class FFIObject(
      protected val pointer: Pointer
  ): Disposable, AutoCloseable {
  
      private val wasDestroyed = AtomicBoolean(false)
      private val callCounter = AtomicLong(1)
  
      open protected fun freeRustArcPtr() {
          // To be overridden in subclasses.
      }
  
      override fun destroy() {
          // Only allow a single call to this method.
          // TODO: maybe we should log a warning if called more than once?
          if (this.wasDestroyed.compareAndSet(false, true)) {
              // This decrement always matches the initial count of 1 given at creation time.
              if (this.callCounter.decrementAndGet() == 0L) {
                  this.freeRustArcPtr()
              }
          }
***************
*** 619,736 ****
                      }
              }
  
      fun get(handle: Handle) = lock.withLock {
          leftMap[handle]
      }
  
      fun delete(handle: Handle) {
          this.remove(handle)
      }
  
      fun remove(handle: Handle): T? =
          lock.withLock {
              leftMap.remove(handle)?.let { obj ->
                  rightMap.remove(obj)
                  obj
              }
          }
  }
  
  interface ForeignCallback : com.sun.jna.Callback {
      public fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int
  }
  
  // Magic number for the Rust proxy to call using the same mechanism as every other method,
  // to free the callback once it's dropped by Rust.
  internal const val IDX_CALLBACK_FREE = 0
  
  internal abstract class FfiConverterCallbackInterface<CallbackInterface>(
      protected val foreignCallback: ForeignCallback
  ) {
      val handleMap = ConcurrentHandleMap<CallbackInterface>()
  
      // Registers the foreign callback with the Rust side.
      // This method is generated for each callback interface.
      abstract fun register(lib: _UniFFILib)
  
      fun drop(handle: Handle): RustBuffer.ByValue {
          return handleMap.remove(handle).let { RustBuffer.ByValue() }
      }
  
      fun lift(n: Handle) = handleMap.get(n)
  
      fun read(buf: ByteBuffer) = lift(buf.getLong())
  
      fun lower(v: CallbackInterface) =
          handleMap.insert(v).also {
              assert(handleMap.get(it) === v) { "Handle map is not returning the object we just placed there. This is a bug in the HandleMap." }
          }
  
      fun write(v: CallbackInterface, buf: RustBufferBuilder) =
          buf.putLong(lower(v))
  }
  
  
! 
  enum class Network {
!     BITCOIN,TESTNET,SIGNET,REGTEST;
  
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): Network {
              return liftFromRustBuffer(rbuf) { buf -> Network.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer) =
              try { values()[buf.getInt() - 1] }
              catch (e: IndexOutOfBoundsException) {
                  throw RuntimeException("invalid enum value, something is very wrong!!", e)
              }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
          buf.putInt(this.ordinal + 1)
      }
  }
  
  
  
  
  
  
  
  sealed class DatabaseConfig  {
      object Memory : DatabaseConfig()
      
      data class Sled(
          val config: SledDbConfiguration 
          ) : DatabaseConfig()
      
      data class Sqlite(
          val config: SqliteDbConfiguration 
          ) : DatabaseConfig()
      
  
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): DatabaseConfig {
              return liftFromRustBuffer(rbuf) { buf -> DatabaseConfig.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): DatabaseConfig {
              return when(buf.getInt()) {
                  1 -> DatabaseConfig.Memory
                  2 -> DatabaseConfig.Sled(
                      SledDbConfiguration.read(buf)
                      )
                  3 -> DatabaseConfig.Sqlite(
                      SqliteDbConfiguration.read(buf)
                      )
                  else -> throw RuntimeException("invalid enum value, something is very wrong!!")
              }
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
--- 651,794 ----
                      }
              }
  
      fun get(handle: Handle) = lock.withLock {
          leftMap[handle]
      }
  
      fun delete(handle: Handle) {
          this.remove(handle)
      }
  
      fun remove(handle: Handle): T? =
          lock.withLock {
              leftMap.remove(handle)?.let { obj ->
                  rightMap.remove(obj)
                  obj
              }
          }
  }
  
+ /**
+  * @suppress
+  */
  interface ForeignCallback : com.sun.jna.Callback {
      public fun invoke(handle: Handle, method: Int, args: RustBuffer.ByValue, outBuf: RustBufferByReference): Int
  }
  
  // Magic number for the Rust proxy to call using the same mechanism as every other method,
  // to free the callback once it's dropped by Rust.
  internal const val IDX_CALLBACK_FREE = 0
  
  internal abstract class FfiConverterCallbackInterface<CallbackInterface>(
      protected val foreignCallback: ForeignCallback
  ) {
      val handleMap = ConcurrentHandleMap<CallbackInterface>()
  
      // Registers the foreign callback with the Rust side.
      // This method is generated for each callback interface.
      abstract fun register(lib: _UniFFILib)
  
      fun drop(handle: Handle): RustBuffer.ByValue {
          return handleMap.remove(handle).let { RustBuffer.ByValue() }
      }
  
      fun lift(n: Handle) = handleMap.get(n)
  
      fun read(buf: ByteBuffer) = lift(buf.getLong())
  
      fun lower(v: CallbackInterface) =
          handleMap.insert(v).also {
              assert(handleMap.get(it) === v) { "Handle map is not returning the object we just placed there. This is a bug in the HandleMap." }
          }
  
      fun write(v: CallbackInterface, buf: RustBufferBuilder) =
          buf.putLong(lower(v))
  }
  
  
! /**
!  * The bitcoin network to operate on
!  */
  enum class Network {
!     /**
!      * Bitcoin's mainnet
!      */
!     BITCOIN,
!     /**
!      * Bitcoin's testnet
!      */
!     TESTNET,
!     /**
!      * Bitcoin's signet
!      */
!     SIGNET,
!     /**
!      * Bitcoin's regtest
!      */
!     REGTEST;
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): Network {
              return liftFromRustBuffer(rbuf) { buf -> Network.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer) =
              try { values()[buf.getInt() - 1] }
              catch (e: IndexOutOfBoundsException) {
                  throw RuntimeException("invalid enum value, something is very wrong!!", e)
              }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
          buf.putInt(this.ordinal + 1)
      }
  }
  
  
  
  
  
  
  
  sealed class DatabaseConfig  {
      object Memory : DatabaseConfig()
      
      data class Sled(
          val config: SledDbConfiguration 
          ) : DatabaseConfig()
      
      data class Sqlite(
          val config: SqliteDbConfiguration 
          ) : DatabaseConfig()
      
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): DatabaseConfig {
              return liftFromRustBuffer(rbuf) { buf -> DatabaseConfig.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): DatabaseConfig {
              return when(buf.getInt()) {
                  1 -> DatabaseConfig.Memory
                  2 -> DatabaseConfig.Sled(
                      SledDbConfiguration.read(buf)
                      )
                  3 -> DatabaseConfig.Sqlite(
                      SqliteDbConfiguration.read(buf)
                      )
                  else -> throw RuntimeException("invalid enum value, something is very wrong!!")
              }
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
***************
*** 750,860 ****
              }
              is DatabaseConfig.Sqlite -> {
                  buf.putInt(3)
                  this.config.write(buf)
                  
              }
          }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
      }
  
      
      
  }
  
  
  
  
  
  
  
  sealed class Transaction  {
!     
      data class Unconfirmed(
!         val details: TransactionDetails 
          ) : Transaction()
!     
      data class Confirmed(
!         val details: TransactionDetails, 
!         val confirmation: BlockTime 
          ) : Transaction()
-     
  
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): Transaction {
              return liftFromRustBuffer(rbuf) { buf -> Transaction.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): Transaction {
              return when(buf.getInt()) {
                  1 -> Transaction.Unconfirmed(
                      TransactionDetails.read(buf)
                      )
                  2 -> Transaction.Confirmed(
                      TransactionDetails.read(buf),
                      BlockTime.read(buf)
                      )
                  else -> throw RuntimeException("invalid enum value, something is very wrong!!")
              }
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
          when(this) {
              is Transaction.Unconfirmed -> {
                  buf.putInt(1)
                  this.details.write(buf)
!                 
              }
              is Transaction.Confirmed -> {
                  buf.putInt(2)
                  this.details.write(buf)
                  this.confirmation.write(buf)
!                 
              }
          }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
      }
  
!     
!     
  }
  
  
  
  
  
  
  
  sealed class BlockchainConfig  {
      
      data class Electrum(
          val config: ElectrumConfig 
          ) : BlockchainConfig()
      
      data class Esplora(
          val config: EsploraConfig 
          ) : BlockchainConfig()
      
  
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): BlockchainConfig {
              return liftFromRustBuffer(rbuf) { buf -> BlockchainConfig.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): BlockchainConfig {
              return when(buf.getInt()) {
                  1 -> BlockchainConfig.Electrum(
                      ElectrumConfig.read(buf)
                      )
                  2 -> BlockchainConfig.Esplora(
                      EsploraConfig.read(buf)
                      )
                  else -> throw RuntimeException("invalid enum value, something is very wrong!!")
              }
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
--- 808,924 ----
              }
              is DatabaseConfig.Sqlite -> {
                  buf.putInt(3)
                  this.config.write(buf)
                  
              }
          }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
      }
  
      
      
  }
  
  
  
  
  
  
  
  sealed class Transaction  {
! 
      data class Unconfirmed(
!         val details: TransactionDetails
          ) : Transaction()
! 
      data class Confirmed(
!         val details: TransactionDetails,
!         val confirmation: BlockTime
          ) : Transaction()
  
+ 
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): Transaction {
              return liftFromRustBuffer(rbuf) { buf -> Transaction.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): Transaction {
              return when(buf.getInt()) {
                  1 -> Transaction.Unconfirmed(
                      TransactionDetails.read(buf)
                      )
                  2 -> Transaction.Confirmed(
                      TransactionDetails.read(buf),
                      BlockTime.read(buf)
                      )
                  else -> throw RuntimeException("invalid enum value, something is very wrong!!")
              }
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
          when(this) {
              is Transaction.Unconfirmed -> {
                  buf.putInt(1)
                  this.details.write(buf)
! 
              }
              is Transaction.Confirmed -> {
                  buf.putInt(2)
                  this.details.write(buf)
                  this.confirmation.write(buf)
! 
              }
          }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
      }
  
! 
! 
  }
  
  
  
  
  
  
  
  sealed class BlockchainConfig  {
      
      data class Electrum(
          val config: ElectrumConfig 
          ) : BlockchainConfig()
      
      data class Esplora(
          val config: EsploraConfig 
          ) : BlockchainConfig()
      
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): BlockchainConfig {
              return liftFromRustBuffer(rbuf) { buf -> BlockchainConfig.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): BlockchainConfig {
              return when(buf.getInt()) {
                  1 -> BlockchainConfig.Electrum(
                      ElectrumConfig.read(buf)
                      )
                  2 -> BlockchainConfig.Esplora(
                      EsploraConfig.read(buf)
                      )
                  else -> throw RuntimeException("invalid enum value, something is very wrong!!")
              }
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
***************
*** 865,908 ****
              is BlockchainConfig.Electrum -> {
                  buf.putInt(1)
                  this.config.write(buf)
                  
              }
              is BlockchainConfig.Esplora -> {
                  buf.putInt(2)
                  this.config.write(buf)
                  
              }
          }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
      }
  
      
      
  }
  
  
  
  
! 
  enum class WordCount {
!     WORDS12,WORDS15,WORDS18,WORDS21,WORDS24;
  
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): WordCount {
              return liftFromRustBuffer(rbuf) { buf -> WordCount.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer) =
              try { values()[buf.getInt() - 1] }
              catch (e: IndexOutOfBoundsException) {
                  throw RuntimeException("invalid enum value, something is very wrong!!", e)
              }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
          buf.putInt(this.ordinal + 1)
      }
  }
--- 929,996 ----
              is BlockchainConfig.Electrum -> {
                  buf.putInt(1)
                  this.config.write(buf)
                  
              }
              is BlockchainConfig.Esplora -> {
                  buf.putInt(2)
                  this.config.write(buf)
                  
              }
          }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
      }
  
      
      
  }
  
  
  
  
! /**
!  * Type describing entropy length (aka word count) in the mnemonic
!  */
  enum class WordCount {
!     /**
!      * 12 words mnemonic (128 bits entropy)
!      */
!     WORDS12,
!     /**
!      * 15 words mnemonic (160 bits entropy)
!      */
!     WORDS15,
!     /**
!      * 18 words mnemonic (192 bits entropy)
!      */
!     WORDS18,
!     /**
!      * 21 words mnemonic (224 bits entropy)
!      */
!     WORDS21,
!     /**
!      * 24 words mnemonic (256 bits entropy)
!      */
!     WORDS24;
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): WordCount {
              return liftFromRustBuffer(rbuf) { buf -> WordCount.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer) =
              try { values()[buf.getInt() - 1] }
              catch (e: IndexOutOfBoundsException) {
                  throw RuntimeException("invalid enum value, something is very wrong!!", e)
              }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
          buf.putInt(this.ordinal + 1)
      }
  }
***************
*** 1045,1084 ****
--- 1133,1175 ----
      
      @Throws(BdkException::class)override fun sync(progressUpdate: BdkProgress, maxAddressParam: UInt? ) =
          callWithPointer {
      rustCallWithError(BdkException) { status ->
      _UniFFILib.INSTANCE.bdk_9c03_Wallet_sync(it, FfiConverterCallbackInterfaceBdkProgress.lower(progressUpdate), lowerOptionalUInt(maxAddressParam) , status)
  }
          }
      
      
      @Throws(BdkException::class)override fun broadcast(psbt: PartiallySignedBitcoinTransaction ): String =
          callWithPointer {
      rustCallWithError(BdkException) { status ->
      _UniFFILib.INSTANCE.bdk_9c03_Wallet_broadcast(it, psbt.lower() , status)
  }
          }.let {
              String.lift(it)
          }
      
      
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(ptr: Pointer): Wallet {
              return Wallet(ptr)
          }
  
          internal fun read(buf: ByteBuffer): Wallet {
              // The Rust code always writes pointers as 8 bytes, and will
              // fail to compile if they don't fit.
              return Wallet.lift(Pointer(buf.getLong()))
          }
  
          
      }
  }
  
  public interface PartiallySignedBitcoinTransactionInterface {
      
      fun serialize(): String
      
  }
***************
*** 1108,1147 ****
--- 1199,1241 ----
  
      internal fun lower(): Pointer = callWithPointer { it }
  
      internal fun write(buf: RustBufferBuilder) {
          // The Rust code always expects pointers written as 8 bytes,
          // and will fail to compile if they don't fit.
          buf.putLong(Pointer.nativeValue(this.lower()))
      }
  
      override fun serialize(): String =
          callWithPointer {
      rustCall() { status ->
      _UniFFILib.INSTANCE.bdk_9c03_PartiallySignedBitcoinTransaction_serialize(it,  status)
  }
          }.let {
              String.lift(it)
          }
      
      
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(ptr: Pointer): PartiallySignedBitcoinTransaction {
              return PartiallySignedBitcoinTransaction(ptr)
          }
  
          internal fun read(buf: ByteBuffer): PartiallySignedBitcoinTransaction {
              // The Rust code always writes pointers as 8 bytes, and will
              // fail to compile if they don't fit.
              return PartiallySignedBitcoinTransaction.lift(Pointer(buf.getLong()))
          }
  
          
      }
  }
  
  public interface TxBuilderInterface {
      
      fun addRecipient(address: String, amount: ULong ): TxBuilder
      
      fun feeRate(satPerVbyte: Float ): TxBuilder
***************
*** 1217,1410 ****
--- 1311,1547 ----
          callWithPointer {
      rustCall() { status ->
      _UniFFILib.INSTANCE.bdk_9c03_TxBuilder_drain_to(it, address.lower() , status)
  }
          }.let {
              TxBuilder.lift(it)
          }
      
      
      @Throws(BdkException::class)override fun build(wallet: Wallet ): PartiallySignedBitcoinTransaction =
          callWithPointer {
      rustCallWithError(BdkException) { status ->
      _UniFFILib.INSTANCE.bdk_9c03_TxBuilder_build(it, wallet.lower() , status)
  }
          }.let {
              PartiallySignedBitcoinTransaction.lift(it)
          }
      
      
  
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(ptr: Pointer): TxBuilder {
              return TxBuilder(ptr)
          }
  
          internal fun read(buf: ByteBuffer): TxBuilder {
              // The Rust code always writes pointers as 8 bytes, and will
              // fail to compile if they don't fit.
              return TxBuilder.lift(Pointer(buf.getLong()))
          }
  
          
      }
  }
  
  data class SledDbConfiguration (
      var path: String, 
      var treeName: String 
  )  {
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): SledDbConfiguration {
              return liftFromRustBuffer(rbuf) { buf -> SledDbConfiguration.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): SledDbConfiguration {
              return SledDbConfiguration(
              String.read(buf),
              String.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
              this.path.write(buf)
          
              this.treeName.write(buf)
          
      }
  
      
      
  }
  
  data class SqliteDbConfiguration (
      var path: String 
  )  {
+ 
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): SqliteDbConfiguration {
              return liftFromRustBuffer(rbuf) { buf -> SqliteDbConfiguration.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): SqliteDbConfiguration {
              return SqliteDbConfiguration(
              String.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
              this.path.write(buf)
          
      }
  
      
      
  }
  
+ /**
+  * A wallet transaction
+  *
+  * @property[fees] Fee value (sats) if available. The availability of the fee depends on the backend. It’s never None with an Electrum Server backend, but it could be None with a Bitcoin RPC node without txindex that receive funds while offline.
+  * @property[received] Received value (sats)
+  * @property[sent] Sent value (sats)
+  * @property[txid] Transaction id
+  */
  data class TransactionDetails (
      var fees: ULong?, 
      var received: ULong, 
      var sent: ULong, 
      var txid: String 
  )  {
+ 
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): TransactionDetails {
              return liftFromRustBuffer(rbuf) { buf -> TransactionDetails.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): TransactionDetails {
              return TransactionDetails(
              readOptionalULong(buf),
              ULong.read(buf),
              ULong.read(buf),
              String.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
              writeOptionalULong(this.fees, buf)
          
              this.received.write(buf)
          
              this.sent.write(buf)
          
              this.txid.write(buf)
          
      }
  
      
      
  }
  
+ /**
+  * Block height and timestamp of a block
+  *
+  * @property[height] confirmation block height
+  * @property[timestamp] confirmation block timestamp
+  */
  data class BlockTime (
      var height: UInt, 
      var timestamp: ULong 
  )  {
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): BlockTime {
              return liftFromRustBuffer(rbuf) { buf -> BlockTime.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): BlockTime {
              return BlockTime(
              UInt.read(buf),
              ULong.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
              this.height.write(buf)
          
              this.timestamp.write(buf)
          
      }
  
      
      
  }
  
+ /**
+  * Configuration for a BlockchainConfig.Electrum
+  *
+  * @property[url] URL of the Electrum server (such as ElectrumX, Esplora, BWT) may start with `ssl://` or `tcp://` and include a port, e.g. `ssl://electrum.blockstream.info:60002`
+  * @property[socks5] URL of the socks5 proxy server or a Tor service
+  * @property[retry] Request retry count
+  * @property[timeout] Request timeout (seconds)
+  * @property[stopGap] Stop searching addresses for transactions after finding an unused gap of this length
+  */
  data class ElectrumConfig (
      var url: String, 
      var socks5: String?, 
      var retry: UByte, 
      var timeout: UByte?, 
      var stopGap: ULong 
  )  {
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): ElectrumConfig {
              return liftFromRustBuffer(rbuf) { buf -> ElectrumConfig.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): ElectrumConfig {
              return ElectrumConfig(
              String.read(buf),
              readOptionalString(buf),
              UByte.read(buf),
              readOptionalUByte(buf),
              ULong.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
***************
*** 1415,1454 ****
--- 1552,1594 ----
          
              this.retry.write(buf)
          
              writeOptionalUByte(this.timeout, buf)
          
              this.stopGap.write(buf)
          
      }
  
      
      
  }
  
  data class EsploraConfig (
      var baseUrl: String, 
      var proxy: String?, 
      var timeoutRead: ULong, 
      var timeoutWrite: ULong, 
      var stopGap: ULong 
  )  {
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): EsploraConfig {
              return liftFromRustBuffer(rbuf) { buf -> EsploraConfig.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): EsploraConfig {
              return EsploraConfig(
              String.read(buf),
              readOptionalString(buf),
              ULong.read(buf),
              ULong.read(buf),
              ULong.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
***************
*** 1457,1496 ****
--- 1597,1639 ----
          
              writeOptionalString(this.proxy, buf)
          
              this.timeoutRead.write(buf)
          
              this.timeoutWrite.write(buf)
          
              this.stopGap.write(buf)
          
      }
  
      
      
  }
  
  data class ExtendedKeyInfo (
      var mnemonic: String, 
      var xprv: String, 
      var fingerprint: String 
  )  {
+     /**
+      * @suppress
+      */
      companion object {
          internal fun lift(rbuf: RustBuffer.ByValue): ExtendedKeyInfo {
              return liftFromRustBuffer(rbuf) { buf -> ExtendedKeyInfo.read(buf) }
          }
  
          internal fun read(buf: ByteBuffer): ExtendedKeyInfo {
              return ExtendedKeyInfo(
              String.read(buf),
              String.read(buf),
              String.read(buf)
              )
          }
      }
  
      internal fun lower(): RustBuffer.ByValue {
          return lowerIntoRustBuffer(this, {v, buf -> v.write(buf)})
      }
  
      internal fun write(buf: RustBufferBuilder) {
              this.mnemonic.write(buf)
***************
*** 1535,1574 ****
--- 1678,1720 ----
          class InvalidNetwork(message: String) : BdkException(message)
          class InvalidProgressValue(message: String) : BdkException(message)
          class ProgressUpdateException(message: String) : BdkException(message)
          class InvalidOutpoint(message: String) : BdkException(message)
          class Descriptor(message: String) : BdkException(message)
          class AddressValidator(message: String) : BdkException(message)
          class Encode(message: String) : BdkException(message)
          class Miniscript(message: String) : BdkException(message)
          class Bip32(message: String) : BdkException(message)
          class Secp256k1(message: String) : BdkException(message)
          class Json(message: String) : BdkException(message)
          class Hex(message: String) : BdkException(message)
          class Psbt(message: String) : BdkException(message)
          class PsbtParse(message: String) : BdkException(message)
          class Electrum(message: String) : BdkException(message)
          class Esplora(message: String) : BdkException(message)
          class Sled(message: String) : BdkException(message)
          class Rusqlite(message: String) : BdkException(message)
          
  
+     /**
+      * @suppress
+      */
      companion object ErrorHandler : CallStatusErrorHandler<BdkException> {
          override fun lift(error_buf: RustBuffer.ByValue): BdkException {
              return liftFromRustBuffer(error_buf) { error_buf -> read(error_buf) }
          }
  
          fun read(error_buf: ByteBuffer): BdkException {
              
                  return when(error_buf.getInt()) {
                  1 -> BdkException.InvalidU32Bytes(String.read(error_buf))
                  2 -> BdkException.Generic(String.read(error_buf))
                  3 -> BdkException.ScriptDoesntHaveAddressForm(String.read(error_buf))
                  4 -> BdkException.NoRecipients(String.read(error_buf))
                  5 -> BdkException.NoUtxosSelected(String.read(error_buf))
                  6 -> BdkException.OutputBelowDustLimit(String.read(error_buf))
                  7 -> BdkException.InsufficientFunds(String.read(error_buf))
                  8 -> BdkException.BnBTotalTriesExceeded(String.read(error_buf))
                  9 -> BdkException.BnBNoExactMatch(String.read(error_buf))
                  10 -> BdkException.UnknownUtxo(String.read(error_buf))
                  11 -> BdkException.TransactionNotFound(String.read(error_buf))
                  12 -> BdkException.TransactionConfirmed(String.read(error_buf))
